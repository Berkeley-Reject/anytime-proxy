# Collection

## Vector

The vector (`Vec<T>`) collection stores more than one value in a single data structure that puts all the values next to each other in memory.

The `Vec::new` function could create a new empty vector with specific type `<T>`. The `vec!` macro could create a vector with initial values and infer the type of the value.

```rs
let vector_1: Vec<i32> = Vec::new();

let vector_2 = vec![1, 2, 3];
```

The `push` method could append values to the end of the vector. The vector is freed when it goes out of scope.

```rs
let mut vector_1: Vec<i32> = Vec::new();
vector_1.push(1);
```

The vector implements two options to access the value in it:

- The `get` method returns a value with `Option<&T>` type. If the index is outside of vector, the `Option` resolves to `None`.
- The `[]` operator returns a reference with `&T` type. If the index is outside of vector, the program will panic.

```rs
let third: &i32 = &v[2];
println!("The third element is {}", third);

match v.get(2) {
    Some(third) => println!("The third element is {}", third),
    None => println!("There is no third element."),
}
```

The `for <element_name> in &<vector_name>` syntax could iterate through all of the elements in the vector. The dereference operator `*` could mutate the value of the mutable reference refers to.

```rs
let vector_1 = vec![100, 32, 57];

for i in &vector_1 {
    println!("{}", i);
}

for i in &mut vector_1 {
    *i += 10;
}
```

## String

The string (`String`) collection store a collection of bytes, which is growable, mutable, owned, and UTF-8 encoded.

The `String::new` function could create an empty string. The `to_string` method, which is available on the type that implements the `Display` trait, could turn another variable into the `String` type.

```rs
let mut s = String::new();
let init_s = String::from("initial contents");
```

- The `push_str` method takes a string slice and append it to the end of the string.
- The `push` method takes a character and append it to the end of the string.

The `format!` macro returns a `String` with the content and the code generated by the macro uses references, thus it won't take ownership of its parameters.

```rs
let s = format!("{}-{}-{}", s1, s2, s3);
```

The `String` type is a wrapper over a `Vec<u8>`, and it doesn't support indexing because it's not clear whether a byte value, a character, or a grapheme cluster should be used.

The `chars` and `bytes` methods could iterate through the Unicode scalar values or raw bytes of `String`.

```rs
for c in "hello".chars() {
    println!("{}", c);
}
```

## Hash Map

The hash map (`HashMap<K, V>`) collection stores a mapping of keys of type `K` to values of type `V` and determines how it places these keys and values into memory through a hashing function.

The `HashMap::new` function could create an empty hash map. The `insert` method could insert a new key-value pair or replace an existing key-value pair for the hash map.

```rs
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 50);
```

For type that implements the `Copy` trait, the value is copied into the hash map. For owned value like `String`, the value will be moved and the hash map will be the owner of the value.

The `get` method accepts a key and returns a value with `Option<&V>` type. If the value is not in the hash map, the `Option` resolves to `None`.

The `for (<key>, <value>) in &<hash_map_name>` syntax could iterate through all of the key-value pair in the hash map.

```rs
for (key, value) in &scores {
    println!("{}: {}", key, value);
}
```

The `entry` method returns an `Entry` enum that represents a key that might or might not exist. The `or_insert` method on `Entry` is defined to return a mutable reference to the value for the corresponding `Entry` key if that key exists, and if not, inserts the parameter as the new value for this key and returns a mutable reference to the new value.

```rs
let default_score = 10;
let score = scores.entry(String::from("Yellow")).or_insert(default_score);
*score += 1;
```
