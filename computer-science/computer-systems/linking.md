# Linking

Linking is the process of collecting and combining various pieces of code and data into a single file that can be loaded into memory and executed. Linking is performed by programs called linkers.

## Compiler Drivers

The compiler driver invokes the language preprocessor, compiler, assembler, and linker to translate ASCII source files into executable object files.

1. **Preprocessor** translates source file `main.c` into an ASCII intermediate file `main.i`.
2. **Compiler** translates `main.i` into an ASCII assembly-language file `main.s`.
3. **Assembler** translates `main.s` into binary relocatable object file `main.o`.
4. **Linker** combines different object files to create the binary executable file `prog`.

## Static Linking

The static linker (e.g. `ld` program) takes a collection of relocatable object files and command-line arguments to generate a fully linked executable object file that could be loaded and run.

- Symbol resolution: Object files define and reference symbols, where each symbol corresponds to a function, a global variable, or a static variable. The linker associates each symbol referenece with one symbol definition.
- Relocation: The linker relocates the code and data sections by associating a memory location with each symbol definition, and pointing all references to the symbols to this memory location.

## Object Files

- Relocatable object file contains binary code and data in a form tha could be combined with other relocatable objeect files at compile time. (Generated by assembler and compiler)
- Shared object file is a special type of relocatable object file that could be loaded into memory and linked dynamically at load or run time. (Generated by assembler and compiler)
- Executable object file contains binary code and data in a form that could be copied into memory and executed. (Generated by linker)

## Relocatable Object Files

Modern x86-64 Linux systems use Executable and Linkable Format (ELF) for object files.

- ELF Header: Word size and byte ordering of the system. The size of ELF header, the object file type (relocatable, etc.), the machine type (x86-64, etc.), the offset of the section header table, and the size and number of entires in the section header table.
- `.text`: The machine code of the compiled program.
- `.rodata`: Read-only data such as jump tables.
- `.data`: Initialized global and static variables. Local variables are maintained on the stack at run time.
- `.bss`: Uninitialized or zero-valued global and static variables. This section is a placeholder that occupies no actual space in the object file. These variables are allocated at runtime in memory.
- `.symtab`: The symbol table with information about functions and global variables that are defined and referenced in the program.
- `.rel.text`: The list of locations in the `.text` section that will need to be modified when the linker combines the file with others. Any instruction that calls an external function or reference a global variable should be modified.
- `.rel.data`: Relocation information for any global variables that are referenced or defined by the module.Any global variable whose initial value is the address of a global variable or external function should be modified.
- `.debug`: The debugging symbol table with entires for local variables, typedefs, global variables, and original C source file.
- `.line`: The mapping between line numbers in the original C source file and machine code instructions in the `.text` section.
- `.strtab`: The string table (a sequence of null-terminated character strings) for the symbol tables in the `symtab` and `.debug` section, and the section names in the section headers.
- Section header table: The locations and sizes of the various sections.

## Symbols and Symbol Tables

Each relocatable object module has a symbol table that contains information about the symbols that are defined and referenced in the module.

- Global symbols are defined by the module and could be referenced by other modules. (e.g. nonstatic functions and global variables)
- Global symbols that are referenced by the module but defined externally.
- Local symbols that are defined and referenced exclusively by the module. (e.g. static functions and global variables)

```cpp
typedef struct {
  int name; // String table offset
  char type: 4, binding: 4; // Function or data, local or global
  char reserved; // Unused
  short section; // Section header index (.data, .bss, etc.)
  long value; // Section offset or absolute address
  long size; // Object size in bytes
} Elf64_Symbol;
```

Pseudosections that don't have entires in the section header table:

- ABS: symbols that shoudn't be relocated
- UNDEF: undefined symbols
- COMMON: uninitialized global variables (GCC assigns these symbols to COMMON instead of `.bss`.)

## Symbol Resolution

